//go:generate go run .
//go:generate gofmt -s -w ../datasheet.go

package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"gopkg.in/yaml.v2"
)

// tpl template of datasheet.go
var tpl = template.Must(template.New("datasheet").Parse(`
// Code generated by gen/generate.go. DO NOT EDIT.
// Generate from datasheet/holidays_detailed.yml

package holiday

// holidays holds the parse result of datasheet/holidays_detailed.yml
var holidays = Holidays{
{{- range $key, $value := .Data }}
	"{{ $key }}": Holiday{
		"date":    "{{ $value.date }}",
		"week":    "{{ $value.week }}",
		"week_en": "{{ $value.week_en }}",
		"name":    "{{ $value.name }}",
		"name_en": "{{ $value.name_en }}",
	},
{{- end }}
}
`))

func main() {
	src := filepath.Join("..", "datasheet", "holidays_detailed.yml")
	out := filepath.Join("..", "datasheet.go")

	data, parseErr := parse(src)
	if parseErr != nil {
		log.Fatalln(parseErr.Error())
	}

	file, fileErr := os.Create(out)
	if fileErr != nil {
		log.Fatalln(fileErr.Error())
	}
	defer file.Close()

	if genErr := generate(data, file); genErr != nil {
		log.Fatalln(genErr.Error())
	}
}

// parse yaml file and returns master data.
func parse(filename string) (map[string]map[string]string, error) {
	file, fileErr := os.Open(filename)
	if fileErr != nil {
		return nil, fmt.Errorf("open file: %w", fileErr)
	}
	defer file.Close()

	var data = map[string]map[string]string{}

	if err := yaml.NewDecoder(file).Decode(&data); err != nil {
		return nil, fmt.Errorf("unmarshal: %w", err)
	}

	return data, nil
}

// generate code from template and master data.
func generate(data map[string]map[string]string, w io.Writer) error {
	inventory := struct {
		Data map[string]map[string]string
	}{
		Data: data,
	}

	if err := tpl.Execute(w, inventory); err != nil {
		return fmt.Errorf("template execute: %w", err)
	}

	return nil
}
